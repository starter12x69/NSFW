
from flask import Flask, render_template, request, jsonify
from flask_cors import CORS
import requests
import base64
import io
import json
import logging
import os
from typing import Dict, Any, Optional

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

# Configuration
RUNPOD_API_BASE_URL = os.getenv('RUNPOD_API_URL', 'http://123.456.78.9:3000')
API_TIMEOUT = 300  # 5 minutes timeout for image generation

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/generate', methods=['POST'])
def generate_image():
    """
    Generate images using Stable Diffusion Automatic1111 API
    
    Expected JSON payload:
    {
        "prompt": "description of image to generate",
        "count": 1  # optional, defaults to 1
    }
    
    Returns:
    {
        "success": true/false,
        "images": ["base64_string1", "base64_string2", ...],
        "message": "status message",
        "error": "error details if any"
    }
    """
    try:
        # Validate request
        if not request.is_json:
            return jsonify({
                'success': False,
                'error': 'Content-Type must be application/json'
            }), 400
        
        data = request.get_json()
        prompt = data.get('prompt', '').strip()
        count = data.get('count', 1)
        
        # Validate inputs
        if not prompt:
            return jsonify({
                'success': False,
                'error': 'Prompt is required and cannot be empty'
            }), 400
        
        if not isinstance(count, int) or count < 1 or count > 5:
            return jsonify({
                'success': False,
                'error': 'Count must be an integer between 1 and 5'
            }), 400
        
        logger.info(f"Generating {count} image(s) for prompt: {prompt}")
        
        # Prepare API request payload
        api_payload = {
            "prompt": prompt,
            "negative_prompt": "blurry, low quality, distorted, deformed",
            "steps": 30,
            "sampler_name": "DPM++ 2M Karras",
            "cfg_scale": 7,
            "width": 512,
            "height": 512,
            "batch_size": count,
            "n_iter": 1,
            "restore_faces": True,
            "enable_hr": False
        }
        
        # Make request to Stable Diffusion API
        api_url = f"{RUNPOD_API_BASE_URL}/sdapi/v1/txt2img"
        
        try:
            response = requests.post(
                api_url,
                json=api_payload,
                timeout=API_TIMEOUT,
                headers={'Content-Type': 'application/json'}
            )
            
            if response.status_code != 200:
                logger.error(f"API request failed with status {response.status_code}: {response.text}")
                return jsonify({
                    'success': False,
                    'error': f'API request failed with status {response.status_code}',
                    'details': response.text[:200]  # Limit error details
                }), 500
            
            api_response = response.json()
            
            # Extract base64 images from response
            images = api_response.get('images', [])
            
            if not images:
                logger.error("No images returned from API")
                return jsonify({
                    'success': False,
                    'error': 'No images were generated by the API'
                }), 500
            
            # Convert images to proper base64 format if needed
            processed_images = []
            for img_b64 in images:
                # Add data URL prefix if not present
                if not img_b64.startswith('data:image/'):
                    img_b64 = f"data:image/png;base64,{img_b64}"
                processed_images.append(img_b64)
            
            logger.info(f"Successfully generated {len(processed_images)} image(s)")
            
            return jsonify({
                'success': True,
                'images': processed_images,
                'message': f'{len(processed_images)} image{"s" if len(processed_images) > 1 else ""} generated successfully',
                'prompt': prompt
            })
            
        except requests.exceptions.Timeout:
            logger.error("API request timed out")
            return jsonify({
                'success': False,
                'error': 'Image generation timed out. Please try again with a simpler prompt.'
            }), 504
            
        except requests.exceptions.ConnectionError:
            logger.error(f"Failed to connect to API at {api_url}")
            return jsonify({
                'success': False,
                'error': 'Unable to connect to the image generation service. Please try again later.'
            }), 503
            
        except requests.exceptions.RequestException as e:
            logger.error(f"API request error: {str(e)}")
            return jsonify({
                'success': False,
                'error': 'An error occurred while communicating with the image generation service.'
            }), 500
    
    except json.JSONDecodeError:
        return jsonify({
            'success': False,
            'error': 'Invalid JSON payload'
        }), 400
        
    except Exception as e:
        logger.error(f"Unexpected error in generate_image: {str(e)}")
        return jsonify({
            'success': False,
            'error': 'An unexpected error occurred. Please try again.'
        }), 500

@app.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({
        'status': 'healthy',
        'service': 'NSFW AI Image Generator',
        'api_configured': bool(RUNPOD_API_BASE_URL)
    })

@app.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Endpoint not found'}), 404

@app.errorhandler(405)
def method_not_allowed(error):
    return jsonify({'error': 'Method not allowed'}), 405

@app.errorhandler(500)
def internal_error(error):
    return jsonify({'error': 'Internal server error'}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=False)
